{"ast":null,"code":"import \"../components/node.css\";\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction FloydWarshall(grid, src, dst) {\n  /*\n  childNode matrix to keep track of child Node of \n  Nodes included in the shortest path \n  from source to destination. Number of rows =\n  number of columns = 100 (total possible vertices).\n  childNode[a][b]: first intermediate Node in shortest path\n  from Node a to Node b.\n   Initialize:\n  childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n  childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n   Update:\n  childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n  */\n  var childNode = new Array(num_of_rows * num_of_cols);\n\n  for (let i = 0; i < num_of_rows * num_of_cols; i++) {\n    childNode[i] = new Array(num_of_rows * num_of_cols);\n  }\n  /*\n  distance matrix of number of rows = 100\n  and number of cols = 100 (as total 100 possible vertices)\n   Initialize:\n  distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n  distance[i][j] = weight of edge connecting from Node i to Node j\n  */\n\n\n  var distance = [];\n\n  for (let i = 0; i < num_of_rows * num_of_cols; i++) {\n    distance[i] = new Array(num_of_rows * num_of_cols);\n  }\n\n  for (let i = 0; i < num_of_rows; i++) {\n    for (let j = 0; j < num_of_cols; j++) {\n      var index = i * num_of_cols + j;\n\n      for (let k = 0; k < num_of_rows * num_of_cols; k++) {\n        if (k === index) {\n          distance[index][k] = 0;\n        } else {\n          distance[index][k] = Infinity;\n          childNode[index][k] = -1;\n        }\n      }\n\n      var u = grid[i][j];\n\n      for (let k = 0; k < u.adjacentNodes.length; k++) {\n        var v = u.adjacentNodes[k];\n        var nextIndex = v.x * num_of_cols + v.y;\n        distance[index][nextIndex] = v.weight;\n        childNode[index][nextIndex] = nextIndex;\n      }\n    }\n  }\n\n  var time = 1; // Floyd Warshall\n\n  for (let k = 0; k < num_of_rows * num_of_cols; k++) {\n    var currimdR = Math.floor(k / num_of_cols);\n    var currimdC = k - currimdR * num_of_cols;\n    var imdNode = grid[currimdR][currimdC];\n\n    if ((currimdR !== src.x || currimdC !== src.y) && (currimdR !== dst.x || currimdC !== dst.y)) {\n      animateNode([imdNode, \"fw-imd-processing\", time]);\n    } // animateNode([imdNode, \"fw-imd-processing\", time]);\n\n\n    time += 1;\n\n    for (let i = 0; i < num_of_rows * num_of_cols; i++) {\n      if (distance[i][k] === Infinity) {\n        continue;\n      }\n\n      var currsrcR = Math.floor(i / num_of_cols);\n      var currsrcC = i - currsrcR * num_of_cols; // if (currsrcR!==currimdR || currsrcC!==currimdC) {\n      // animateNode([grid[currsrcR][currsrcC], \"fw-src-processing\", time]);\n      // time += 0.5;\n      // }\n\n      time += 1;\n\n      for (let j = 0; j < num_of_rows * num_of_cols; j++) {\n        if (distance[k][j] === Infinity) {\n          continue;\n        }\n\n        var currdstR = Math.floor(j / num_of_cols);\n        var currdstC = j - currdstR * num_of_cols; // if (currdstR!==currimdR || currdstC!==currimdC) {\n        // animateNode([grid[currdstR][currdstC], \"fw-dst-processing\", time]);\n        // time += 3;\n        // }\n        // time += 0.5;\n\n        if (distance[i][j] > distance[i][k] + distance[k][j]) {\n          distance[i][j] = distance[i][k] + distance[k][j];\n          childNode[i][j] = childNode[i][k];\n        } // time += 0.5;\n        // if (currdstR!==currimdR || currdstC!==currimdC) {\n        // animateNode([grid[currdstR][currdstC], \"fw-processed\", time]);\n        // time += 1;\n        // }\n\n      } // if (currsrcR!==currimdR || currsrcC!==currimdC) {\n      // animateNode([grid[currsrcR][currsrcC], \"fw-processed\", time]);\n      // time += 0.5;\n      // }\n      // time += 0.5;\n\n    }\n\n    if ((currimdR !== src.x || currimdC !== src.y) && (currimdR !== dst.x || currimdC !== dst.y)) {\n      animateNode([imdNode, \"fw-processed\", time]);\n    } // animateNode([grid[currimdR][currimdC], \"fw-processed\", time]);\n\n\n    time += 1;\n  }\n\n  var startIndex = src.x * num_of_cols + src.y;\n  var endIndex = dst.x * num_of_cols + dst.y;\n  console.log(distance[startIndex][endIndex] + src.weight);\n  var shortestDistance = distance[startIndex][endIndex] + src.weight;\n  var shortestPath = [];\n\n  while (startIndex !== endIndex) {\n    var r = Math.floor(startIndex / num_of_cols);\n    var c = startIndex - r * num_of_cols;\n\n    if ((r !== src.x || c !== src.y) && (r !== dst.x || c !== dst.y)) {\n      shortestPath.push(grid[r][c]);\n    }\n\n    startIndex = childNode[startIndex][endIndex];\n  } // shortestPath.push(grid[dst.x][dst.y]);\n\n\n  for (let k = 0; k < shortestPath.length; k++) {\n    console.log(shortestPath[k]);\n  }\n\n  animateShortestPath(shortestPath, time);\n  return [shortestDistance, time];\n}\n\nfunction animateNode(toBeAnimated) {\n  var node = toBeAnimated[0];\n  var newClass = toBeAnimated[1];\n  var time = toBeAnimated[2];\n  setTimeout(() => {\n    document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n  }, 10 * time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n  for (let i = 0; i < shortestPath.length; i++) {\n    setTimeout(() => {\n      var node = shortestPath[i];\n      document.getElementById(`node-${node.x}-${node.y}`).className = 'fw-shortest-path';\n    }, 10 * time);\n  }\n}\n\nexport default FloydWarshall;","map":{"version":3,"sources":["/Users/ahmadfajar/Masters/Computer Science/Algorithm/graph/Shortest-Path-Algorithms-Visualizer-source-code/src/algorithms/FloydWarshall.js"],"names":["num_of_rows","num_of_cols","FloydWarshall","grid","src","dst","childNode","Array","i","distance","j","index","k","Infinity","u","adjacentNodes","length","v","nextIndex","x","y","weight","time","currimdR","Math","floor","currimdC","imdNode","animateNode","currsrcR","currsrcC","currdstR","currdstC","startIndex","endIndex","console","log","shortestDistance","shortestPath","r","c","push","animateShortestPath","toBeAnimated","node","newClass","setTimeout","document","getElementById","className"],"mappings":"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","sourcesContent":["import \"../components/node.css\";\n\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction FloydWarshall(grid, src, dst) {\n    /*\n    childNode matrix to keep track of child Node of \n    Nodes included in the shortest path \n    from source to destination. Number of rows =\n    number of columns = 100 (total possible vertices).\n    childNode[a][b]: first intermediate Node in shortest path\n    from Node a to Node b.\n\n    Initialize:\n    childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n    childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n\n    Update:\n    childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n    */\n    var childNode = new Array(num_of_rows*num_of_cols);\n    for (let i=0; i<num_of_rows*num_of_cols; i++) {\n        childNode[i] = new Array(num_of_rows*num_of_cols);\n    }\n    /*\n    distance matrix of number of rows = 100\n    and number of cols = 100 (as total 100 possible vertices)\n\n    Initialize:\n    distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n    distance[i][j] = weight of edge connecting from Node i to Node j\n    */\n    var distance = [];\n    for (let i=0; i<num_of_rows*num_of_cols; i++) {\n        distance[i] = new Array(num_of_rows*num_of_cols);\n    }\n    for (let i=0; i<num_of_rows; i++) {\n        for (let j=0; j<num_of_cols; j++) {\n            var index = i*(num_of_cols) + j;\n            for (let k=0; k<num_of_rows*num_of_cols; k++) {\n                if (k===index) {distance[index][k] = 0;}\n                else {\n                    distance[index][k] = Infinity;\n                    childNode[index][k] = -1;\n                }\n            }\n            var u = grid[i][j];\n            for (let k=0; k<u.adjacentNodes.length; k++) {\n                var v = u.adjacentNodes[k];\n                var nextIndex = v.x*(num_of_cols) + v.y;\n                distance[index][nextIndex] = v.weight;\n                childNode[index][nextIndex] = nextIndex;\n            }\n        }\n    }\n    var time = 1;\n    // Floyd Warshall\n    for (let k=0; k<num_of_rows*num_of_cols; k++) {\n        var currimdR = Math.floor(k/num_of_cols);\n        var currimdC = k - (currimdR*num_of_cols);\n        var imdNode = grid[currimdR][currimdC];\n        if ((currimdR!==src.x || currimdC!==src.y) && (currimdR!==dst.x || currimdC!==dst.y)) {\n            animateNode([imdNode, \"fw-imd-processing\", time]);\n        }\n        // animateNode([imdNode, \"fw-imd-processing\", time]);\n        time += 1;\n        for (let i=0; i<num_of_rows*num_of_cols; i++) {\n            if (distance[i][k] === Infinity) {continue;}\n            var currsrcR = Math.floor(i/num_of_cols);\n            var currsrcC = i - (currsrcR*num_of_cols);\n\n            // if (currsrcR!==currimdR || currsrcC!==currimdC) {\n                // animateNode([grid[currsrcR][currsrcC], \"fw-src-processing\", time]);\n                // time += 0.5;\n            // }\n            time += 1;\n            for (let j=0; j<num_of_rows*num_of_cols; j++) {\n                if (distance[k][j] === Infinity) {\n                    continue;\n                }\n                var currdstR = Math.floor(j/num_of_cols);\n                var currdstC = j - (currdstR*num_of_cols);\n\n                // if (currdstR!==currimdR || currdstC!==currimdC) {\n                    // animateNode([grid[currdstR][currdstC], \"fw-dst-processing\", time]);\n                    // time += 3;\n                // }\n                // time += 0.5;\n                if (distance[i][j] > distance[i][k] + distance[k][j]) {\n                    distance[i][j] = distance[i][k] + distance[k][j];\n                    childNode[i][j] = childNode[i][k];\n                }\n                // time += 0.5;\n                // if (currdstR!==currimdR || currdstC!==currimdC) {\n                    // animateNode([grid[currdstR][currdstC], \"fw-processed\", time]);\n                    // time += 1;\n                // }\n            }\n            // if (currsrcR!==currimdR || currsrcC!==currimdC) {\n                // animateNode([grid[currsrcR][currsrcC], \"fw-processed\", time]);\n                // time += 0.5;\n            // }\n            // time += 0.5;\n        }\n        if ((currimdR!==src.x || currimdC!==src.y) && (currimdR!==dst.x || currimdC!==dst.y)) {\n            animateNode([imdNode, \"fw-processed\", time]);\n        }\n        // animateNode([grid[currimdR][currimdC], \"fw-processed\", time]);\n        time += 1;\n    }\n    var startIndex = src.x*(num_of_cols) + src.y;\n    var endIndex = dst.x*(num_of_cols) + dst.y;\n    console.log(distance[startIndex][endIndex]+src.weight);\n    var shortestDistance = distance[startIndex][endIndex]+src.weight;\n    var shortestPath = [];\n    while (startIndex !== endIndex) {\n        var r = Math.floor(startIndex/num_of_cols);\n        var c = startIndex - (r*num_of_cols);\n        if ((r!==src.x || c!==src.y) && (r!==dst.x || c!==dst.y)) {\n            shortestPath.push(grid[r][c]);\n        }\n        startIndex = childNode[startIndex][endIndex];\n    }\n    // shortestPath.push(grid[dst.x][dst.y]);\n    for (let k=0; k<shortestPath.length; k++) {\n        console.log(shortestPath[k]);\n    }\n    animateShortestPath(shortestPath, time);\n    return [shortestDistance, time];\n}\n\nfunction animateNode(toBeAnimated) {\n    var node = toBeAnimated[0];\n    var newClass = toBeAnimated[1];\n    var time = toBeAnimated[2];\n    setTimeout(() => {\n        document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n    }, 10*time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n    for (let i=0; i<shortestPath.length; i++) {\n        setTimeout(() => {\n            var node = shortestPath[i];\n            document.getElementById(`node-${node.x}-${node.y}`).className = 'fw-shortest-path';\n        }, 10*time);\n    }\n}\n\nexport default FloydWarshall;"]},"metadata":{},"sourceType":"module"}