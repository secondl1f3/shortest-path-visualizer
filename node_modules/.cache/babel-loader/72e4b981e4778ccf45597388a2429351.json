{"ast":null,"code":"import \"../components/node.css\";\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction BellmanFord(grid, src, dst) {\n  // to store the distances\n  var distance = [];\n\n  for (let i = 0; i < num_of_rows; i++) {\n    distance[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      // Initialize all distances as Infinity\n      distance[i][j] = Infinity;\n    }\n  } // initialize source distance as weight of source node\n\n\n  distance[src.x][src.y] = src.weight; // to keep track of parent Node of \n  // Nodes included in the shortest path\n\n  var parentNodes = []; // initialize all parent nodes as null\n\n  for (let i = 0; i < num_of_rows; i++) {\n    parentNodes[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      parentNodes[i][j] = null;\n    }\n  }\n\n  var time = 1;\n\n  for (let count = 0; count < num_of_rows * num_of_cols; count++) {\n    var flag = false;\n\n    for (let i = 0; i < num_of_rows; i++) {\n      for (let j = 0; j < num_of_cols; j++) {\n        var curr = grid[i][j];\n\n        if ((curr.x !== src.x || curr.y !== src.y) && (curr.x !== dst.x || curr.y !== dst.y)) {\n          animateNode([curr, \"bellman-ford-processing\", time]);\n        }\n\n        time += 0.5;\n\n        for (let k = 0; k < curr.adjacentNodes.length; k++) {\n          var adj = curr.adjacentNodes[k];\n\n          if ((adj.x !== src.x || adj.y !== src.y) && (adj.x !== dst.x || adj.y !== dst.y)) {\n            animateNode([adj, \"bellman-ford-processing\", time]);\n          }\n\n          time += 1;\n\n          if (distance[adj.x][adj.y] > distance[curr.x][curr.y] + adj.weight) {\n            flag = true;\n            distance[adj.x][adj.y] = distance[curr.x][curr.y] + adj.weight;\n            parentNodes[adj.x][adj.y] = curr;\n          }\n\n          if ((adj.x !== src.x || adj.y !== src.y) && (adj.x !== dst.x || adj.y !== dst.y)) {\n            animateNode([adj, \"bellman-ford-processed\", time]);\n          }\n\n          time += 1;\n        }\n\n        if ((curr.x !== src.x || curr.y !== src.y) && (curr.x !== dst.x || curr.y !== dst.y)) {\n          animateNode([curr, \"bellman-ford-processed\", time]);\n        }\n\n        time += 0.5;\n      }\n    }\n\n    if (flag === false) {\n      break;\n    }\n  }\n\n  if (distance[dst.x][dst.y] !== Infinity) {\n    console.log(\"Path Found!\");\n    console.log(distance[dst.x][dst.y]);\n  } // to keep track of nodes included in\n  // shortest path for animation\n\n\n  var shortestPath = [];\n  var end = parentNodes[dst.x][dst.y];\n\n  while (end.x !== src.x || end.y !== src.y) {\n    shortestPath.unshift(end);\n    end = parentNodes[end.x][end.y];\n  }\n\n  for (var k = 0; k < shortestPath.length; k++) {\n    console.log(shortestPath[k]);\n  }\n\n  animateShortestPath(shortestPath, time);\n  return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n  var node = toBeAnimated[0];\n  var newClass = toBeAnimated[1];\n  var time = toBeAnimated[2];\n  setTimeout(() => {\n    document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n  }, 10 * time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n  for (let i = 0; i < shortestPath.length; i++) {\n    setTimeout(() => {\n      var node = shortestPath[i];\n      document.getElementById(`node-${node.x}-${node.y}`).className = 'bellman-ford-shortest-path';\n    }, 10 * time);\n  }\n}\n\nexport default BellmanFord;","map":{"version":3,"sources":["/Users/ahmadfajar/Masters/Computer Science/Algorithm/graph/Shortest-Path-Algorithms-Visualizer-source-code/src/algorithms/BellmanFord.js"],"names":["num_of_rows","num_of_cols","BellmanFord","grid","src","dst","distance","i","Array","j","Infinity","x","y","weight","parentNodes","time","count","flag","curr","animateNode","k","adjacentNodes","length","adj","console","log","shortestPath","end","unshift","animateShortestPath","toBeAnimated","node","newClass","setTimeout","document","getElementById","className"],"mappings":"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","sourcesContent":["import \"../components/node.css\";\n\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction BellmanFord(grid, src, dst) {\n    // to store the distances\n    var distance = [];\n    for (let i=0; i<num_of_rows; i++) {\n        distance[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            // Initialize all distances as Infinity\n            distance[i][j] = Infinity;\n        }\n    }\n    // initialize source distance as weight of source node\n    distance[src.x][src.y] = src.weight;\n    // to keep track of parent Node of \n    // Nodes included in the shortest path\n    var parentNodes = [];\n    // initialize all parent nodes as null\n    for (let i=0; i<num_of_rows; i++) {\n        parentNodes[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            parentNodes[i][j] = null;\n        }\n    }\n    var time = 1;\n    for (let count=0; count<(num_of_rows*num_of_cols); count++) {\n        var flag = false;\n        for (let i=0; i<num_of_rows; i++) {\n            for (let j=0; j<num_of_cols; j++) {\n                var curr = grid[i][j];\n                if ((curr.x!==src.x || curr.y!==src.y) && (curr.x!==dst.x || curr.y!==dst.y)) {\n                    animateNode([curr, \"bellman-ford-processing\", time]);\n                }\n                time += 0.5;\n                for (let k=0; k<curr.adjacentNodes.length; k++) {\n                    var adj = curr.adjacentNodes[k];\n                    if ((adj.x!==src.x || adj.y!==src.y) && (adj.x!==dst.x || adj.y!==dst.y)) {\n                        animateNode([adj, \"bellman-ford-processing\", time]);\n                    }\n                    time += 1;\n                    if (distance[adj.x][adj.y] > distance[curr.x][curr.y] + adj.weight) {\n                        flag = true;\n                        distance[adj.x][adj.y] = distance[curr.x][curr.y] + adj.weight;\n                        parentNodes[adj.x][adj.y] = curr;\n                    }\n                    if ((adj.x!==src.x || adj.y!==src.y) && (adj.x!==dst.x || adj.y!==dst.y)) {\n                        animateNode([adj, \"bellman-ford-processed\", time]);\n                    }\n                    time += 1;\n                }\n                if ((curr.x!==src.x || curr.y!==src.y) && (curr.x!==dst.x || curr.y!==dst.y)) {\n                    animateNode([curr, \"bellman-ford-processed\", time]);\n                }\n                time += 0.5;\n            }\n        }\n        if (flag === false) {break;}\n    }\n    if (distance[dst.x][dst.y] !== Infinity) {\n        console.log(\"Path Found!\");\n        console.log(distance[dst.x][dst.y]);\n    }\n    // to keep track of nodes included in\n    // shortest path for animation\n    var shortestPath = [];\n    var end = parentNodes[dst.x][dst.y];\n    while (end.x !== src.x || end.y !== src.y) {\n        shortestPath.unshift(end);\n        end = parentNodes[end.x][end.y];\n    }\n    for (var k=0; k<shortestPath.length; k++) {\n        console.log(shortestPath[k]);\n    }\n    animateShortestPath(shortestPath, time);\n    return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n    var node = toBeAnimated[0];\n    var newClass = toBeAnimated[1];\n    var time = toBeAnimated[2];\n    setTimeout(() => {\n        document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n    }, 10*time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n    for (let i=0; i<shortestPath.length; i++) {\n        setTimeout(() => {\n            var node = shortestPath[i];\n            document.getElementById(`node-${node.x}-${node.y}`).className = 'bellman-ford-shortest-path';\n        }, 10*time);\n    }\n}\n\nexport default BellmanFord;"]},"metadata":{},"sourceType":"module"}