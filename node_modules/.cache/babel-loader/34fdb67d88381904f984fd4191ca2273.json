{"ast":null,"code":"import PriorityQueue from \"../structures/PriorityQueue\";\nimport \"../components/node.css\";\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction Dijkstra(grid, src, dst) {\n  // to store the distances\n  var distance = [];\n\n  for (let i = 0; i < num_of_rows; i++) {\n    distance[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      // Initialize all distances as Infinity\n      distance[i][j] = Infinity;\n    }\n  } // initialize source distance as weight of source node\n\n\n  distance[src.x][src.y] = src.weight; // to keep track of parent Node of \n  // Nodes included in the shortest path\n\n  var parentNodes = []; // initialize all parent nodes as null\n\n  for (let i = 0; i < num_of_rows; i++) {\n    parentNodes[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      parentNodes[i][j] = null;\n    }\n  }\n\n  var time = 1;\n  var pq = new PriorityQueue();\n  pq.insert([src, src.weight]);\n\n  while (!pq.isEmpty()) {\n    var currentVertex = pq.extractMin();\n    var curr = currentVertex[0]; // push processed vertex for animation\n    // animateNode([curr, \"processed\", t]);\n\n    if ((curr.x !== src.x || curr.y !== src.y) && (curr.x !== dst.x || curr.y !== dst.y)) {\n      animateNode([curr, \"dijkstra-processed\", time]);\n    }\n\n    time++; // Shortest Path Found\n\n    if (curr.x === dst.x && curr.y === dst.y) {\n      break;\n    }\n\n    for (let k = 0; k < curr.adjacentNodes.length; k++) {\n      var adj = curr.adjacentNodes[k];\n\n      if (distance[adj.x][adj.y] > distance[curr.x][curr.y] + adj.weight) {\n        // update \"curr\" as parent node of \"adj\"\n        parentNodes[adj.x][adj.y] = curr; // if adjacent node already present in priority queue, \n        // then remove it first.\n\n        if (distance[adj.x][adj.y] !== Infinity) {\n          pq.deleteKey(adj.x, adj.y);\n        } // update it's distance\n\n\n        distance[adj.x][adj.y] = distance[curr.x][curr.y] + adj.weight;\n        pq.insert([adj, distance[adj.x][adj.y]]); // animateNode([adj, \"processing\", t]);\n\n        if (adj.x !== dst.x || adj.y !== dst.y) {\n          animateNode([adj, \"dijkstra-processing\", time]);\n        }\n\n        time++;\n      }\n    }\n  }\n\n  if (distance[dst.x][dst.y] !== Infinity) {\n    console.log(\"Path Found!\");\n    console.log(distance[dst.x][dst.y]);\n  } // to keep track of nodes included in\n  // shortest path for animation\n\n\n  var shortestPath = [];\n  var end = parentNodes[dst.x][dst.y];\n\n  while (end.x !== src.x || end.y !== src.y) {\n    shortestPath.unshift(end);\n    end = parentNodes[end.x][end.y];\n  } // for (var k=0; k<shortestPath.length; k++) {\n  //     console.log(shortestPath[k]);\n  // }\n\n\n  animateShortestPath(shortestPath, time);\n  return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n  var node = toBeAnimated[0];\n  var newClass = toBeAnimated[1];\n  var time = toBeAnimated[2];\n  setTimeout(() => {\n    document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n  }, 40 * time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n  for (let i = 0; i < shortestPath.length; i++) {\n    setTimeout(() => {\n      var node = shortestPath[i];\n      document.getElementById(`node-${node.x}-${node.y}`).className = 'dijkstra-shortest-path';\n    }, 40 * time);\n  }\n}\n\nexport default Dijkstra;","map":{"version":3,"sources":["/Users/ahmadfajar/Masters/Computer Science/Algorithm/graph/Shortest-Path-Algorithms-Visualizer-source-code/src/algorithms/Dijkstra.js"],"names":["PriorityQueue","num_of_rows","num_of_cols","Dijkstra","grid","src","dst","distance","i","Array","j","Infinity","x","y","weight","parentNodes","time","pq","insert","isEmpty","currentVertex","extractMin","curr","animateNode","k","adjacentNodes","length","adj","deleteKey","console","log","shortestPath","end","unshift","animateShortestPath","toBeAnimated","node","newClass","setTimeout","document","getElementById","className"],"mappings":"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","sourcesContent":["import PriorityQueue from \"../structures/PriorityQueue\";\nimport \"../components/node.css\";\n\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction Dijkstra(grid, src, dst) {\n    // to store the distances\n    var distance = [];\n    for (let i=0; i<num_of_rows; i++) {\n        distance[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            // Initialize all distances as Infinity\n            distance[i][j] = Infinity;\n        }\n    }\n    // initialize source distance as weight of source node\n    distance[src.x][src.y] = src.weight;\n    // to keep track of parent Node of \n    // Nodes included in the shortest path\n    var parentNodes = [];\n    // initialize all parent nodes as null\n    for (let i=0; i<num_of_rows; i++) {\n        parentNodes[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            parentNodes[i][j] = null;\n        }\n    }\n    var time = 1;\n    var pq = new PriorityQueue();\n    pq.insert([src, src.weight]);\n    while (!pq.isEmpty()) {\n        var currentVertex = pq.extractMin();\n        var curr = currentVertex[0];\n        // push processed vertex for animation\n        // animateNode([curr, \"processed\", t]);\n        if ((curr.x!==src.x || curr.y!==src.y) && (curr.x!==dst.x || curr.y!==dst.y)) {\n            animateNode([curr, \"dijkstra-processed\", time]);\n        }\n        time++;\n        // Shortest Path Found\n        if (curr.x === dst.x && curr.y === dst.y) {\n            break;\n        }\n        for (let k=0; k<curr.adjacentNodes.length; k++) {\n            var adj = curr.adjacentNodes[k];\n            if (distance[adj.x][adj.y] > distance[curr.x][curr.y] + adj.weight) {\n                // update \"curr\" as parent node of \"adj\"\n                parentNodes[adj.x][adj.y] = curr;\n                // if adjacent node already present in priority queue, \n                // then remove it first.\n                if (distance[adj.x][adj.y] !== Infinity) {\n                    pq.deleteKey(adj.x, adj.y);\n                }\n                // update it's distance\n                distance[adj.x][adj.y] = distance[curr.x][curr.y] + adj.weight;\n                pq.insert([adj, distance[adj.x][adj.y]]);\n                // animateNode([adj, \"processing\", t]);\n                if (adj.x!==dst.x || adj.y!==dst.y) {\n                    animateNode([adj, \"dijkstra-processing\", time]);\n                }\n                time++;\n            }\n        }\n    }\n    if (distance[dst.x][dst.y] !== Infinity) {\n        console.log(\"Path Found!\");\n        console.log(distance[dst.x][dst.y]);\n    }\n    // to keep track of nodes included in\n    // shortest path for animation\n    var shortestPath = [];\n    var end = parentNodes[dst.x][dst.y];\n    while (end.x !== src.x || end.y !== src.y) {\n        shortestPath.unshift(end);\n        end = parentNodes[end.x][end.y];\n    }\n    // for (var k=0; k<shortestPath.length; k++) {\n    //     console.log(shortestPath[k]);\n    // }\n    animateShortestPath(shortestPath, time);\n    return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n    var node = toBeAnimated[0];\n    var newClass = toBeAnimated[1];\n    var time = toBeAnimated[2];\n    setTimeout(() => {\n        document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n    }, 40*time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n    for (let i=0; i<shortestPath.length; i++) {\n        setTimeout(() => {\n            var node = shortestPath[i];\n            document.getElementById(`node-${node.x}-${node.y}`).className = 'dijkstra-shortest-path';\n        }, 40*time);\n    }\n}\n\nexport default Dijkstra;"]},"metadata":{},"sourceType":"module"}