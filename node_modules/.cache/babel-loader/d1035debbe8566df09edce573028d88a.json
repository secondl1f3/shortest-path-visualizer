{"ast":null,"code":"import Queue from \"../structures/Queue\";\nimport \"../components/node.css\";\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction BFS(grid, src, dst) {\n  // to store the distances\n  var distance = [];\n\n  for (let i = 0; i < num_of_rows; i++) {\n    distance[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      // Initialize all distances as Infinity\n      distance[i][j] = Infinity;\n    }\n  } // initialize source distance as weight of source node\n\n\n  distance[src.x][src.y] = 0; // to keep track of parent Node of \n  // Nodes included in the shortest path\n\n  var parentNodes = []; // initialize all parent nodes as null\n\n  for (let i = 0; i < num_of_rows; i++) {\n    parentNodes[i] = new Array(num_of_cols);\n\n    for (let j = 0; j < num_of_cols; j++) {\n      parentNodes[i][j] = null;\n    }\n  }\n\n  var time = 1;\n  var q = new Queue();\n  q.insert(src);\n\n  while (q.isEmpty() === false) {\n    var pathFound = false;\n    var curr = q.remove();\n\n    for (let k = 0; k < curr.adjacentNodes.length; k++) {\n      var adj = curr.adjacentNodes[k];\n\n      if ((adj.x !== src.x || adj.y !== src.y) && (adj.x !== dst.x || adj.y !== dst.y) && distance[adj.x][adj.y] === Infinity) {\n        animateNode([adj, \"bfs-processed\", time]);\n      }\n\n      time++;\n\n      if (distance[adj.x][adj.y] === Infinity) {\n        distance[adj.x][adj.y] = distance[curr.x][curr.y] + 1;\n        parentNodes[adj.x][adj.y] = curr;\n\n        if (adj.x === dst.x && adj.y === dst.y) {\n          pathFound = true;\n          break;\n        }\n\n        q.insert(adj);\n      }\n    }\n\n    if (pathFound) {\n      break;\n    }\n  }\n\n  if (distance[dst.x][dst.y] !== Infinity) {\n    console.log(\"Path Found!\");\n    console.log(distance[dst.x][dst.y]);\n  } // to keep track of nodes included in\n  // shortest path for animation\n\n\n  var shortestPath = [];\n  var end = parentNodes[dst.x][dst.y];\n\n  while (end.x !== src.x || end.y !== src.y) {\n    shortestPath.unshift(end);\n    end = parentNodes[end.x][end.y];\n  }\n\n  for (var k = 0; k < shortestPath.length; k++) {\n    console.log(shortestPath[k]);\n  }\n\n  animateShortestPath(shortestPath, time);\n  return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n  var node = toBeAnimated[0];\n  var newClass = toBeAnimated[1];\n  var time = toBeAnimated[2];\n  setTimeout(() => {\n    document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n  }, 40 * time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n  for (let i = 0; i < shortestPath.length; i++) {\n    setTimeout(() => {\n      var node = shortestPath[i];\n      document.getElementById(`node-${node.x}-${node.y}`).className = 'bfs-shortest-path';\n    }, 40 * time);\n  }\n}\n\nexport default BFS;","map":{"version":3,"sources":["/Users/ahmadfajar/Masters/Computer Science/Algorithm/graph/Shortest-Path-Algorithms-Visualizer-source-code/src/algorithms/BFS.js"],"names":["Queue","num_of_rows","num_of_cols","BFS","grid","src","dst","distance","i","Array","j","Infinity","x","y","parentNodes","time","q","insert","isEmpty","pathFound","curr","remove","k","adjacentNodes","length","adj","animateNode","console","log","shortestPath","end","unshift","animateShortestPath","toBeAnimated","node","newClass","setTimeout","document","getElementById","className"],"mappings":"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","sourcesContent":["import Queue from \"../structures/Queue\";\nimport \"../components/node.css\";\n\nconst num_of_rows = 10;\nconst num_of_cols = 10;\n\nfunction BFS(grid, src, dst) {\n    // to store the distances\n    var distance = [];\n    for (let i=0; i<num_of_rows; i++) {\n        distance[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            // Initialize all distances as Infinity\n            distance[i][j] = Infinity;\n        }\n    }\n    // initialize source distance as weight of source node\n    distance[src.x][src.y] = 0;\n    // to keep track of parent Node of \n    // Nodes included in the shortest path\n    var parentNodes = [];\n    // initialize all parent nodes as null\n    for (let i=0; i<num_of_rows; i++) {\n        parentNodes[i] = new Array(num_of_cols);\n        for (let j=0; j<num_of_cols; j++) {\n            parentNodes[i][j] = null;\n        }\n    }\n    var time = 1;\n    var q = new Queue();\n    q.insert(src);\n    while (q.isEmpty()===false) {\n        var pathFound = false;\n        var curr = q.remove();\n        for (let k=0; k<curr.adjacentNodes.length; k++) {\n            var adj = curr.adjacentNodes[k];\n            if ((adj.x!==src.x || adj.y!==src.y) && (adj.x!==dst.x || adj.y!==dst.y) && (distance[adj.x][adj.y]===Infinity)) {\n                animateNode([adj, \"bfs-processed\", time]);\n            }\n            time++;\n            if (distance[adj.x][adj.y] === Infinity) {\n                distance[adj.x][adj.y] = distance[curr.x][curr.y]+1;\n                parentNodes[adj.x][adj.y] = curr;\n                if (adj.x === dst.x && adj.y === dst.y)  {\n                    pathFound = true;\n                    break;\n                }\n                q.insert(adj);\n            }\n        }\n        if (pathFound) {break;}\n    }\n    if (distance[dst.x][dst.y] !== Infinity) {\n        console.log(\"Path Found!\");\n        console.log(distance[dst.x][dst.y]);\n    }\n    // to keep track of nodes included in\n    // shortest path for animation\n    var shortestPath = [];\n    var end = parentNodes[dst.x][dst.y];\n    while (end.x !== src.x || end.y !== src.y) {\n        shortestPath.unshift(end);\n        end = parentNodes[end.x][end.y];\n    }\n    for (var k=0; k<shortestPath.length; k++) {\n        console.log(shortestPath[k]);\n    }\n    animateShortestPath(shortestPath, time);\n    return [distance[dst.x][dst.y], time];\n}\n\nfunction animateNode(toBeAnimated) {\n    var node = toBeAnimated[0];\n    var newClass = toBeAnimated[1];\n    var time = toBeAnimated[2];\n    setTimeout(() => {\n        document.getElementById(`node-${node.x}-${node.y}`).className = newClass;\n    }, 40*time);\n}\n\nfunction animateShortestPath(shortestPath, time) {\n    for (let i=0; i<shortestPath.length; i++) {\n        setTimeout(() => {\n            var node = shortestPath[i];\n            document.getElementById(`node-${node.x}-${node.y}`).className = 'bfs-shortest-path';\n        }, 40*time);\n    }\n}\n\nexport default BFS;"]},"metadata":{},"sourceType":"module"}